# ğŸ“š MÃ³dulo de RevisÃ£o - ExercÃ­cios e Desafios

## ğŸ“Œ VisÃ£o Geral

O mÃ³dulo de RevisÃ£o consolida todos os conceitos fundamentais de C# atravÃ©s de exercÃ­cios prÃ¡ticos e desafios reais. Ã‰ o lugar perfeito para reforÃ§ar o aprendizado e desenvolver confianÃ§a na programaÃ§Ã£o.

## ğŸ¯ Objetivos de Aprendizado

- Consolidar conceitos de C# atravÃ©s da prÃ¡tica
- Resolver problemas usando diferentes abordagens
- Aplicar conhecimentos em cenÃ¡rios reais
- Desenvolver habilidades de pensamento lÃ³gico
- Preparar-se para desafios mais complexos

## ğŸ“– ConteÃºdo

### 1ï¸âƒ£ ManipulaÃ§Ã£o de Dados
**Objetivo**: Dominar operaÃ§Ãµes com tipos primitivos e estruturas de dados.

**ExercÃ­cios**:
- **ConversÃµes NumÃ©ricas**: Parse, TryParse, Convert
- **OperaÃ§Ãµes com Strings**: Trim, ToUpper, ToLower, Replace, Split, Substring
- **Data e Hora**: DateTime, TimeSpan, formataÃ§Ã£o
- **OperaÃ§Ãµes MatemÃ¡ticas**: Math.Abs, Math.Floor, Math.Pow, etc
- **ValidaÃ§Ãµes**: Email, CPF, idade, senha forte

**Habilidades**:
- Converter entre tipos com seguranÃ§a
- Manipular strings eficientemente
- Trabalhar com datas
- Realizar validaÃ§Ãµes de dados

### 2ï¸âƒ£ LÃ³gica de ProgramaÃ§Ã£o
**Objetivo**: Resolver problemas algorÃ­tmicos clÃ¡ssicos.

**ExercÃ­cios**:
- **NÃºmeros Pares e Ãmpares**: Filtragem com loops
- **Fatorial Recursivo**: ImplementaÃ§Ã£o de recursÃ£o
- **Fibonacci**: SequÃªncias matemÃ¡ticas
- **NÃºmeros Primos**: VerificaÃ§Ã£o de primalidade
- **Maior e Menor**: Busca de extremos

**Habilidades**:
- Dominar loops (for, while)
- Implementar recursÃ£o
- Usar condicionais
- Identificar padrÃµes

### 3ï¸âƒ£ OrientaÃ§Ã£o a Objetos
**Objetivo**: Aplicar princÃ­pios de POO em exercÃ­cios.

**ExercÃ­cios**:
- **Classe Pessoa**: Atributos, propriedades, mÃ©todos
- **HeranÃ§a com Animais**: Criar classes derivadas
- **Interface VeÃ­culos**: Implementar contratos

**Habilidades**:
- Criar classes e objetos
- Implementar heranÃ§a
- Usar interfaces
- Aplicar encapsulamento

### 4ï¸âƒ£ Algoritmos
**Objetivo**: Implementar algoritmos clÃ¡ssicos de computaÃ§Ã£o.

**ExercÃ­cios**:
- **Busca BinÃ¡ria**: Algoritmo de busca em array ordenado
- **Bubble Sort**: Algoritmo de ordenaÃ§Ã£o
- **InversÃ£o de String**: Reverter e detectar palÃ­ndromos

**Habilidades**:
- Compreender busca e ordenaÃ§Ã£o
- Implementar algoritmos eficientes
- Analisar complexidade
- Otimizar performance

### 5ï¸âƒ£ ColeÃ§Ãµes
**Objetivo**: Usar coleÃ§Ãµes para resolver problemas prÃ¡ticos.

**ExercÃ­cios**:
- **Lista de Compras**: CRUD com List<T>
- **DicionÃ¡rio de Estoque**: Pares chave-valor
- **Valores Ãšnicos**: HashSet para remover duplicatas

**Habilidades**:
- Escolher a coleÃ§Ã£o apropriada
- OperaÃ§Ãµes de CRUD
- Filtragem e busca
- Manipular mÃºltiplas estruturas

### 6ï¸âƒ£ Desafios PrÃ¡ticos
**Objetivo**: Resolver problemas do mundo real.

**Desafios**:
- **Calculadora de IMC**: CÃ¡lculos e classificaÃ§Ã£o
- **Gerenciador de Tarefas**: Sistema completo
- **Sistema de Notas**: CÃ¡lculo de mÃ©dia e situaÃ§Ã£o

**Habilidades**:
- Integrar mÃºltiplos conceitos
- Trabalhar com dados reais
- Criar sistemas funcionais
- Implementar lÃ³gica de negÃ³cio

## ğŸ“Š Matriz de Aprendizado

```
Conceito              | Tipo ExercÃ­cio    | Dificuldade | Status
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€
Tipos de Dados       | ManipulaÃ§Ã£o      | â­         | âœ“
Strings              | ManipulaÃ§Ã£o      | â­â­       | âœ“
Data/Hora            | ManipulaÃ§Ã£o      | â­â­       | âœ“
Loops e CondiÃ§Ãµes    | LÃ³gica           | â­         | âœ“
RecursÃ£o             | LÃ³gica           | â­â­â­     | âœ“
Classes              | POO              | â­â­       | âœ“
HeranÃ§a              | POO              | â­â­â­     | âœ“
Interfaces           | POO              | â­â­â­     | âœ“
Busca BinÃ¡ria        | Algoritmo        | â­â­â­     | âœ“
OrdenaÃ§Ã£o            | Algoritmo        | â­â­       | âœ“
Listas               | ColeÃ§Ãµes         | â­â­       | âœ“
DicionÃ¡rios          | ColeÃ§Ãµes         | â­â­â­     | âœ“
HashSet              | ColeÃ§Ãµes         | â­â­       | âœ“
Sistemas Complexos   | PrÃ¡tico          | â­â­â­â­   | âœ“
```

## ğŸ’¡ EstratÃ©gias de Estudo

### 1. Incremente a Dificuldade Gradualmente
```
FÃ¡cil â†’ MÃ©dio â†’ DifÃ­cil â†’ Muito DifÃ­cil
  â­    â­â­    â­â­â­    â­â­â­â­
```

### 2. Pratique Regularmente
- **5 minutos**: Ler o problema
- **15 minutos**: Tentar resolver sozinho
- **5 minutos**: Comparar com a soluÃ§Ã£o
- **5 minutos**: Refatorar e otimizar

### 3. Evite Armadilhas Comuns

âŒ **Errados**:
```csharp
// ConversÃ£o sem tratamento de erro
int numero = int.Parse(input); // Pode lanÃ§ar exceÃ§Ã£o

// Busca ineficiente
bool existe = lista.Contains(valor); // O(n) em List

// Strings concatenadas em loop
string resultado = "";
for (int i = 0; i < 1000; i++) {
    resultado += i; // Muito lento
}
```

âœ… **Corretos**:
```csharp
// ConversÃ£o segura
if (int.TryParse(input, out int numero)) {
    // Usar numero
}

// Busca eficiente
bool existe = hashSet.Contains(valor); // O(1) em HashSet

// String concatenaÃ§Ã£o eficiente
var sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.Append(i); // Muito mais rÃ¡pido
}
```

## ğŸ“ Exemplo de ResoluÃ§Ã£o Passo a Passo

### Problema: Verificar se um nÃºmero Ã© primo

**Passo 1**: Entender o problema
- NÃºmero primo Ã© divisÃ­vel apenas por 1 e ele mesmo
- 2, 3, 5, 7, 11 sÃ£o primos
- 4, 6, 8, 9 nÃ£o sÃ£o primos

**Passo 2**: Pensar no algoritmo
```
1. Se nÃºmero < 2: nÃ£o Ã© primo
2. Para cada nÃºmero de 2 atÃ© sqrt(nÃºmero):
   - Se nÃºmero Ã© divisÃ­vel: nÃ£o Ã© primo
3. Se nenhuma divisÃ£o encontrada: Ã© primo
```

**Passo 3**: Implementar
```csharp
bool EhPrimo(int numero) {
    if (numero < 2) return false;
    
    for (int i = 2; i <= Math.Sqrt(numero); i++) {
        if (numero % i == 0)
            return false;
    }
    return true;
}
```

**Passo 4**: Testar
```csharp
// Deve retornar true
EhPrimo(7)  // true
EhPrimo(11) // true

// Deve retornar false
EhPrimo(4)  // false
EhPrimo(1)  // false
```

**Passo 5**: Otimizar
```csharp
// JÃ¡ otimizado usando Math.Sqrt
// Complexity: O(âˆšn)
```

## ğŸ”— Relacionamento com Outros MÃ³dulos

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       REVISÃƒO (ConsolidaÃ§Ã£o)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                 â”‚
â”‚  â”œâ”€ Tipos (tipos primitivos)    â”‚
â”‚  â”œâ”€ Classes (POO)               â”‚
â”‚  â”œâ”€ HeranÃ§a (heranÃ§a)           â”‚
â”‚  â”œâ”€ Interface (contratos)       â”‚
â”‚  â”œâ”€ ColeÃ§Ãµes (estruturas)       â”‚
â”‚  â”œâ”€ ExceÃ§Ãµes (tratamento)       â”‚
â”‚  â””â”€ LINQ (queries)              â”‚
â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“ˆ Progresso de Aprendizado

**Iniciante** (Primeiras 2-3 execuÃ§Ãµes)
- Foco em entender cada exercÃ­cio
- Permitir-se copiar e adaptar
- Executar e ver os resultados

**IntermediÃ¡rio** (PrÃ³ximas 3-5 execuÃ§Ãµes)
- Tentar resolver sem ver o cÃ³digo
- Refatorar soluÃ§Ãµes
- Adicionar novos casos de teste

**AvanÃ§ado** (6+ execuÃ§Ãµes)
- Otimizar para performance
- Adicionar validaÃ§Ãµes
- Criar variaÃ§Ãµes dos exercÃ­cios

## âœ… Checklist de DomÃ­nio

### ManipulaÃ§Ã£o de Dados
- [ ] Converter tipos com Parse/TryParse/Convert
- [ ] Manipular strings (Trim, Split, Replace, etc)
- [ ] Trabalhar com datas
- [ ] Validar entradas

### LÃ³gica de ProgramaÃ§Ã£o
- [ ] Implementar loops corretamente
- [ ] Usar recursÃ£o quando apropriado
- [ ] Identificar padrÃµes
- [ ] Resolver problemas lÃ³gicos

### OrientaÃ§Ã£o a Objetos
- [ ] Criar classes com propriedades/mÃ©todos
- [ ] Implementar heranÃ§a corretamente
- [ ] Usar interfaces para contratos
- [ ] Aplicar encapsulamento

### Algoritmos
- [ ] Entender busca binÃ¡ria
- [ ] Implementar ordenaÃ§Ã£o
- [ ] Analisar complexidade
- [ ] Otimizar performance

### ColeÃ§Ãµes
- [ ] Escolher a coleÃ§Ã£o apropriada
- [ ] Realizar operaÃ§Ãµes CRUD
- [ ] Filtrar e buscar dados
- [ ] Combinar mÃºltiplas estruturas

### Desafios PrÃ¡ticos
- [ ] Integrar mÃºltiplos conceitos
- [ ] Resolver problemas reais
- [ ] Implementar lÃ³gica de negÃ³cio
- [ ] Criar sistemas funcionais

## ğŸš€ PrÃ³ximos Passos

ApÃ³s completar este mÃ³dulo:

1. **Revisit Modules**: Volte aos mÃ³dulos anteriores e crie seus prÃ³prios exemplos
2. **Create Projects**: Desenvolva pequenos projetos usando os conceitos
3. **Read Code**: Leia cÃ³digo de projetos open source
4. **Teach Others**: Explique os conceitos para alguÃ©m
5. **Competitive Programming**: Pratique em sites como HackerRank, LeetCode

## ğŸ“š Recursos Adicionais

- [C# Documentation - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/csharp/)
- [LeetCode](https://leetcode.com/)
- [HackerRank](https://www.hackerrank.com/)
- [Project Euler](https://projecteuler.net/)
- [GeeksforGeeks - C#](https://www.geeksforgeeks.org/csharp-tutorial/)

---

**Lembre-se**: A prÃ¡tica constante Ã© a chave para dominar programaÃ§Ã£o. Quanto mais vocÃª resolver exercÃ­cios, mais natural se tornarÃ¡ pensar em soluÃ§Ãµes!

**Bom estudo! ğŸš€**
